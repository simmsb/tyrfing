//! # Digital to Analog Converter

// TODO: macros for different CPUs which have different peripherals
// FIXME: RUNSTDBY

use core::marker::PhantomData;

use crate::pac::DAC0;
use crate::vref::DACReferenceVoltage;

/// DAC Register interface traits private to this module
mod private {
    pub trait DacRegExt {
        fn enable(&self, enable: bool);
        fn enable_output(&self, enable: bool);
        fn set_value(&self, value: u8);
    }
}

use private::DacRegExt;

/// Enabled DAC (type state)
pub struct Enabled;

/// Disabled DAC (type state)
pub struct Disabled;

/// Enabled DAC that connect be disabled anymore because other peripherals depend on it (type state)
pub struct LockedEnabled;

pub trait ED {}
impl ED for Enabled {}
impl ED for Disabled {}
impl ED for LockedEnabled {}

/// Extension trait that constrains the [`DAC0`] peripheral
pub trait DacExt<INST: DacRegExt, const IDX: u8> {
    /// Constrains the [`DAC0`] peripheral.
    ///
    /// Consumes the [`pac::DAC0`] peripheral and converts it to a [`HAL`] internal type
    /// constraining it's public access surface to fit the design of the `HAL`.
    ///
    /// [`pac::DAC0`]: `crate::pac::DAC0`
    /// [`HAL`]: `crate`
    fn constrain(self, ref_voltage: DACReferenceVoltage<IDX>) -> Dac<INST, Disabled>;
}

/// Constrained DAC peripheral
///
/// An instance of this struct is acquired by calling the [`constrain`](DacExt::constrain) function
/// on the [`DAC0`] struct.
///
/// ```
/// let dp = pac::Peripherals::take().unwrap();
/// let dac = dp.DAC.constrain();
/// ```
pub struct Dac<INST, ED> {
    dac: INST,
    _ref: DACReferenceVoltage<0>,
    _enabled: PhantomData<ED>
}

impl DacExt<DAC0, 0> for DAC0 {
    fn constrain(self, ref_voltage: DACReferenceVoltage<0>) -> Dac<Self, Disabled> {
        Dac {
            dac: self,
            _ref: ref_voltage,
            _enabled: PhantomData
        }
    }
}

impl<INST: DacRegExt> Dac<INST, Disabled> {
    /// Enable the DAC
    pub fn enable(self) -> Dac<INST, Enabled> {
        self.dac.enable(true);

        Dac {
            dac: self.dac,
            _ref: self._ref,
            _enabled: PhantomData
        }
    }

    /// Assign a DAC output pin
    /// 
    /// The DAC can be passed to the Analog Comparator, so a physical output pin
    /// is not always needed
    #[inline]
    pub fn output_pin<P: DACOutputPin>(&mut self, _pin: P) {
        self.dac.enable_output(true);
    }

    /// Set the current DAC output value
    /// 
    /// The value scales the reference voltage that is generated by the [`VREF`](crate::vref::Vref)
    /// peripheral.
    /// 
    /// Make sure to enable the DAC. This function in the [`Disabled`] state is meant to
    /// set a value with the output still disabled to avoid inconsistent output
    #[inline]
    pub fn dac_set_value(&mut self, value: u8) {
        self.dac.set_value(value);
    }
}

impl<INST: DacRegExt> Dac<INST, Enabled> {
    /// Disable the DAC
    pub fn disable(self) -> Dac<INST, Disabled> {
        self.dac.enable(false);

        Dac {
            dac: self.dac,
            _ref: self._ref,
            _enabled: PhantomData
        }
    }

    /// Lock the DAC into an enabled state to pass its output it into other peripherals
    /// 
    /// Once the DAC has been locked, it cannot be disabled anymore
    pub fn lock_enable(self) -> Dac<INST, LockedEnabled> {
        Dac {
            dac: self.dac,
            _ref: self._ref,
            _enabled: PhantomData
        }
    }

    /// Set the current DAC output value
    /// 
    /// The value scales the reference voltage that is generated by the [`VREF`](crate::vref::Vref)
    /// peripheral
    #[inline]
    pub fn dac_set_value(&mut self, value: u8) {
        self.dac.set_value(value);
    }
}

impl<INST: DacRegExt> Dac<INST, LockedEnabled> {
    /// Set the current DAC output value
    /// 
    /// The value scales the reference voltage that is generated by the [`VREF`](crate::vref::Vref)
    /// peripheral
    #[inline]
    pub fn dac_set_value(&mut self, value: u8) {
        self.dac.set_value(value);
    }
}

/// Marker trait for a pin that can be used as a DAC output
pub trait DACOutputPin: crate::private::Sealed {}

/// A virtual DAC output that can be passed into an analog comparator negative
/// input pin
pub struct DACOutputToAC<const IDX: u8>;
impl<const IDX: u8> crate::private::Sealed for DACOutputToAC<IDX> {}



// TODO: implement macros for the following code

impl DacRegExt for DAC0 {
    #[inline]
    fn enable(&self, enable: bool) {
        self.ctrla().modify(|_, w| w.enable().variant(enable));
    }

    #[inline]
    fn enable_output(&self, enable: bool) {
        self.ctrla().modify(|_, w| w.outen().variant(enable));
    }

    #[inline]
    fn set_value(&self, value: u8) {
        self.data().write(|w| w.bits(value));
    }
}

impl<INST: DacRegExt> Dac<INST, LockedEnabled> {
    /// Get the DAC output that can be used as a negative input into AC0
    pub fn dac_get_ac0_input(&self) -> DACOutputToAC<0> {
        DACOutputToAC
    }
}

use crate::gpio::{Output, Stateless};
impl DACOutputPin for crate::gpio::porta::PA6<Output<Stateless>> {}
